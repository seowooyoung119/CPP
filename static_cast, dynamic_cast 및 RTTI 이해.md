# C++ 타입 캐스팅: static_cast, dynamic_cast 및 RTTI 이해
C++에서 타입 캐스팅은 객체의 타입을 다른 타입으로 변환하는 강력한 기능입니다. 하지만 잘못 사용하면 런타임 오류나 정의되지 않은 동작을 초래할 수 있습니다. 여기서는 static_cast, **dynamic_cast**의 주요 문제점과 dynamic_cast가 의존하는 **RTTI (Run-Time Type Information)**에 대해 설명합니다.

<br><br>

## 1. static_cast의 문제점
static_cast는 컴파일 시점에 타입 변환을 수행합니다. 이는 기본 타입 간의 변환이나 상속 계층 내에서 컴파일러가 안전하다고 판단하는 경우에 주로 사용되죠.

🔴문제점:<br>
1️⃣안전성 문제 (다운캐스팅 시): 상속 계층에서 부모 클래스 포인터/참조를 자식 클래스 포인터/참조로 다운캐스팅할 때 가장 큰 위험이 있습니다. 
static_cast는 컴파일러에게 "이 변환이 안전하다고 가정한다"고 알려주는 것과 같아요. 
따라서 실제 객체의 타입과 캐스팅하려는 타입이 일치하지 않아도 컴파일 오류가 발생하지 않습니다.
이로 인해 런타임에 유효하지 않은 메모리 접근이나 **정의되지 않은 동작(Undefined Behavior)**이 발생할 수 있습니다.<br>

![image](https://github.com/user-attachments/assets/985db306-f48f-4c25-8289-545bdc729d70)

형 변환 실패 감지 불가: static_cast는 형 변환이 실패했는지 여부를 런타임에 확인할 방법이 없습니다. dynamic_cast와 달리 nullptr을 반환하거나 예외를 발생시키지 않아요.
<br>

## 2.dynamic_cast의 문제점
dynamic_cast는 런타임에 타입 변환을 수행하며, 주로 다형성을 가진 클래스 계층에서 안전한 다운캐스팅을 위해 사용됩니다. 이 캐스트는 RTTI (Run-Time Type Information)를 필수적으로 요구합니다.

🔴문제점:<br>
1️⃣성능 오버헤드: dynamic_cast는 런타임에 실제 객체의 타입을 확인해야 하므로, static_cast에 비해 상대적으로 성능 오버헤드가 발생할 수 있습니다. 특히 빈번하게 호출될 경우 애플리케이션의 성능에 영향을 줄 수 있죠.<br>

2️⃣다형성 요구 사항: dynamic_cast는 반드시 하나 이상의 가상 함수를 가진 클래스(다형적 클래스)에 대해서만 작동합니다. 가상 함수가 없는 클래스에 dynamic_cast를 사용하려고 하면 컴파일 오류가 발생해요.<br>

3️⃣RTTI 의존성: dynamic_cast는 RTTI에 의존합니다. RTTI를 비활성화하면 dynamic_cast를 사용할 수 없게 되죠. 이는 특정 환경(예: 임베디드 시스템)에서는 RTTI가 비활성화되는 경우가 있어 제약이 될 수 있습니다.<br>

4️⃣설계 문제의 신호: dynamic_cast를 너무 자주 사용해야 하는 코드는 클래스 계층 설계에 문제가 있음을 나타낼 수 있습니다. 일반적으로 다형성을 이용하여 가상 함수 호출을 통해 문제를 해결하는 것이 더 객체 지향적인 방법입니다.<br>
<br>

## 3.RTTI (Run-Time Type Information)
RTTI는 C++ 표준이 제공하는 기능으로, 프로그램 실행 중에 객체의 실제 타입을 확인할 수 있도록 해줍니다. dynamic_cast와 typeid 연산자가 RTTI를 사용해요.<br>

RTTI의 기능:<br>
dynamic_cast: 다형적인 클래스 계층에서 안전하게 다운캐스팅을 수행합니다. 캐스팅이 실패하면 포인터의 경우 nullptr을 반환하고, 참조의 경우 std::bad_cast 예외를 발생시킵니다.<br>

typeid: 객체의 실제 타입 정보를 나타내는 std::type_info 객체의 참조를 반환합니다. std::type_info 객체는 name() 메서드를 통해 타입의 이름을 문자열로 얻을 수 있습니다 (컴파일러 구현에 따라 다름).<br>

🟢RTTI의 장점:<br>
1️⃣안전한 타입 변환: 런타임에 안전하게 타입을 확인하고 변환할 수 있습니다.<br>

2️⃣디버깅 및 로깅: 런타임에 객체의 타입을 확인하고 디버깅 정보나 로그를 생성하는 데 유용합니다.<br>
<br>
🔴RTTI의 단점:<br>
1️⃣성능 오버헤드: RTTI 정보를 유지하고 런타임에 타입 정보를 조회하는 데 약간의 오버헤드가 발생할 수 있습니다.<br>

2️⃣코드 크기 증가: RTTI 정보를 포함하기 위해 실행 파일의 크기가 약간 증가할 수 있습니다.<br>

3️⃣설계 문제의 신호: RTTI를 과도하게 사용하는 것은 객체 지향 원칙에 위배될 수 있으며, 더 나은 다형적 설계로 대체할 수 있는 경우가 많습니다.<br><br><br>

### 끄고 켜는 법

![image](https://github.com/user-attachments/assets/36805727-ad1f-4da6-b5cd-59a204a45c4d)





