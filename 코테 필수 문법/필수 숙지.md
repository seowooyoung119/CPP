## 변수를 만들 때 고려할 것. <br>
-1 어떤 종류의 데이터를 저장할 것인가? <br>
-2 변수에 사용할 이름을 무엇으로 할 건가? <br>

## 변수 데이터 타입 <br>
정수형 short, int, long, long long <br>
실수형 float(정밀도 6), double(정밀도 15) <br>
문자형 char, string <br>
논리형 bool <br>

## 스칼라 타입 = 하나의 데이터를 저장하는 타입<br>
int, lfoat, double, bool, char 등등. <br>

## 아스키 코드표에서 기억할 것
NULL = 데이터상 0 <br>
'0' = 데이터상 48 <br>
'9' = 데이터상 57 <br>
'A' = 데이터상 65 <br>
'Z' = 데이터상 90 <br>
'a' = 데이터상 97 <br>
'z' = 데이터 122 <br>

## 배열
배열 : 하나의 이름으로 동일 타입의 변수를 묶어서 관리 <br>
배열 자체에 값을 복사한다면? 시작 주소를 잃어버려서 메모리 누수가 일어남. (= malloc 사용 시 시작 주소를 잃어버렸을 때 일어나는 메모리 누수) <br>

## Leftvalue / Rightvalue
'=' 대입 연산자 기준 왼쪽, 오른쪽의 데이터들<br>

## string (문자열)
.find(찾으려는 문자열 혹은 문자) - 찾으려는 맨 처음 위치부터 끝까지 검색<br>
.find(찾으려는 문자열 혹은 문자열, 시작 위치) - 시작 위치부터 끝까지 검색<br>
🟥참고1 : find의 시간 복잡도는 O(N)<br>
🟥참고2 : 찾지 못하면 npos 라는 값을 반환<br>

| 항목    | 내용                                                  |
| ----- | --------------------------------------------------- |
| 정의    | `static const size_type npos = -1;`                 |
| 실제 값  | `size_t`의 최대값 (보통 `18446744073709551615` on 64-bit) |
| 사용 목적 | `find()` 등에서 "찾지 못함"을 나타내기 위함                       |
| 비교 방식 | `if (pos == std::string::npos)` 로 확인                |

### 문자열 추가, 수정
기본 추가 : + 연산자를 통해서 가능<br>
🟥추천 : += 또는 append()함수<br>
🟥 왜 이걸 추천하는가? 성능이 다름 <br>
<br>
기본 수정 : [] 연산자 활용 <br>
🟥 추천 : .replace(시작위치, 시작으로부터 바꿀 갯수, 넣을 문자열) 함수 <br>

🟥  분리 : substr(시작 위치, 길이) <br>
시작위치에서 길이만큼의 문자열을 잘라서 반환 <br>


## 그외 알아야 하는 필수 메서드(함수)

| 메서드 이름        | 사용 방법                                 | 동작 설명                      | 시간 복잡도                           |
| ------------- | ------------------------------------- | -------------------------- | -------------------------------- |
| `length()`    | `s.length()`                          | 문자열의 길이를 반환                | O(1)                             |
| `size()`      | `s.size()`                            | `length()`와 동일             | O(1)                             |
| `empty()`     | `s.empty()`                           | 문자열이 비어 있으면 `true` 반환      | O(1)                             |
| `clear()`     | `s.clear()`                           | 문자열을 비움                    | O(1)                             |
| `append()`    | `s.append(추가할 문자열)`<br>`s += 추가할 문자열` | 문자열 끝에 문자열을 추가             | O(n + m)<br>(n: 기존 길이, m: 추가 길이) |
| `insert()`    | `s.insert(삽입 위치, 삽입할 문자열)`            | 지정한 위치에 문자열을 삽입            | O(n + m)                         |
| `erase()`     | `s.erase(시작 위치, 삭제할 길이)`              | 지정한 위치부터 일정 길이만큼 삭제        | O(n - 시작 위치)                     |
| `replace()`   | `s.replace(시작 위치, 교체할 길이, 대체할 문자열)`   | 일부 구간을 다른 문자열로 교체          | O(n - 시작 위치 + m)                 |
| `substr()`    | `s.substr(시작 위치, 길이)`                 | 일부 문자열을 잘라서 반환             | O(m)                             |
| `compare()`   | `s.compare(비교할 문자열)`                  | 두 문자열을 사전 순으로 비교           | O(n) 또는 O((n - 위치) \* m)         |
| `at()`        | `s.at(접근할 위치)`                        | 해당 위치의 문자 반환 (범위 검사 포함)    | O(1)                             |
| `operator[]`  | `s[접근할 위치]`                           | 해당 위치의 문자 반환 (범위 검사 없음)    | O(1)                             |
| `push_back()` | `s.push_back(추가할 문자)`                 | 문자열 끝에 문자 하나 추가            | O(1)                             |
| `pop_back()`  | `s.pop_back()`                        | 문자열 마지막 문자 제거              | O(1)                             |
| `resize()`    | `s.resize(새 크기, 채울 문자)`               | 문자열 크기를 조정 (남는 부분은 문자로 채움) | O(1) 또는 O(n)                     |
| `swap()`      | `s.swap(교환할 문자열)`                     | 두 문자열의 내용을 맞바꿈             | O(1)                             |
| `toupper()`   | `std::toupper(변환할 문자)`                | 문자를 대문자로 변환                | O(1)                             |
| `tolower()`   | `std::tolower(변환할 문자)`                | 문자를 소문자로 변환                | O(1)                             |


---

# 코딩 테스트에서 자주하는 실수 

🟩 논리 연산에서 <br>
AND(&&) : 둘 다 true 면 작동 <br> 
주의 : 앞의 조건(이하 A)가 false 면 뒤의 조건 (이하 B)가 true 라도 상관없이 false가 된다. ⚠️(즉, 뒤의 조건이 검사되지 않음) <br>
<br>
OR(||) : 하나만 true 면 작동 <br> 
주의 : 앞의 조건(이하 A)가 true 면 뒤의 조건 (이하 B)가 false 라도 상관없이 true가 된다. ⚠️(즉, 뒤의 조건이 검사되지 않음) <br>

🟩 배열 접근에서 <br>

🔴루프가 의도한 횟수보다 한 번 더 많이 수행 <br>

![image](https://github.com/user-attachments/assets/a358f8a0-264d-4935-a9fd-0dbd80541af8)

<br>
🔴루프가 의도한 횟수보다 한 번 더 많이 수행 <br>

![image](https://github.com/user-attachments/assets/b659bf1a-4f52-4197-819a-c9eaf6a68791)

<br>
배열의 길이 size(), length()를 적극적으로 활용하자.
<br><br>
🟩 0으로 나누는 상황 <br>
런타임 오류 발생!<br>
0으로 나누어질 경우의 예외처리를 할 것.<br>
<br>
🟩 결과값이 아닌 중간 값의 오버플로우 <br>
<br>
🔴 2 * 5억 * 3/ 10 같은 경우 중간 계산 과정에서 21억을 넘는 오버플로우 발생!<br>
<br>
중간 값이 오버플로우가 되는지 중간 계산을 확인해볼 것.<br>
혹은 계산 순서를 바꿀 수 있으면 바꿔서 오버 플로우를 예방하기 <br>











